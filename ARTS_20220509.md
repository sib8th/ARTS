# 1.两数之和
字典解法，用空间换时间，可以将O(N2)的时间优化到O(N)。
判断数组是否存在两数之和等于target，只需要从头遍历数组，判断target-num[i]是否事先加入了在hashmap，未搜索到目标则将num[i]加入hashmap

# 2.两数相加
双链表逆序存储的多位数相加，低位加到高位，新链表的next指针什么时候能置空，需要在loop内冗余代码多判断一次，要一次循环优雅实现遍历，可增加虚拟头节点，参考如下解法
```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode root = new ListNode(0);
        ListNode cursor = root;
        int carry = 0;
        while(l1 != null || l2 != null || carry != 0) {
            int l1Val = l1 != null ? l1.val : 0;
            int l2Val = l2 != null ? l2.val : 0;
            int sumVal = l1Val + l2Val + carry;
            carry = sumVal / 10;
            
            ListNode sumNode = new ListNode(sumVal % 10);
            cursor.next = sumNode;
            cursor = sumNode;
            
            if(l1 != null) l1 = l1.next;
            if(l2 != null) l2 = l2.next;
        }
        
        return root.next;
    }
}
```

# 3.无重复字符的最长子串
找到从某个字符开始，不包含重复字符的最长子串。采用滑动窗口的思路求解，固定窗口左指针start，右指针end不断右移，直到end+1的字符k和窗口内字符k重复，则窗口内的字符组成最大字串。
此时下一个窗口的左指针应该从窗口内的index(k)+1开始
```
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 记录字符上一次出现的位置
        int[] last = new int[128];
        // 处理最长子串=s的情况
        for(int i = 0; i < 128; i++) {
            last[i] = -1;
        }
        int n = s.length();
        int res = 0;
        int start = 0; // 窗口开始位置
        for(int i = 0; i < n; i++) {
            int index = s.charAt(i);
            start = Math.max(start, last[index] + 1);
            res   = Math.max(res, i - start + 1);
            last[index] = i;
        }

        return res;
    }
}
```

# 4.寻找两个正序数组的中位数
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n))。
此题为hard难度的原因是对时间复杂度做了限制，O(log(m+n))，因此考虑用二分查找法。
先看中位数的定义： 将一个自然数集合划分为两个集合A和B，集合A的所有自然数<=中位数<=集合B的所有自然数
此题等价于在两个正序数组组成的m+n长度的数组中查找第k大的数，长度为奇数，则k=(m+n+1)/2,长度为偶数，则第(m+n)/2和第(m+n)/2+1个数的平均值为中位数。
小trick： 奇数和偶数都可以计算(m+n+1)/2和(m+n+2)/2的平均值
对于当前k，每次比较nums1[k/2]和nums2[k/2]的大小，若nums1[k/2] < nums2[k/2]，则k一定不在nums1[0:k/2]中，排除了nums1的前k/2个数，可以继续比较查找数组剩下部分的第k/2个数。
需要考虑边界情况：
k=1
k/2超出数组限制
```
class Solution {
   public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int x1 = nums1.length + nums2.length + 1;
        int x2 = nums1.length + nums2.length + 2;
        x1/=2;
        x2/=2;
        return ((findKElementRecursive(nums1, 0, nums2, 0, x1)) +  (findKElementRecursive(nums1, 0, nums2, 0, x2)))/ 2;
    }

    public double findKElementRecursive(int[] nums1, int start1, int[] nums2, int start2, int k) {
        if(nums1 == null || start1 >= nums1.length) {
            return nums2[start2 + k - 1];
        }
        if(nums2 == null || start2 >= nums2.length) {
            return nums1[start1 + k - 1];
        }
        if(k == 1) {
            return Math.min(nums1[start1], nums2[start2]);
        }
        int med1 = start1 + k / 2 - 1;
        int med2 = start2 + k / 2 - 1;
        int medVal1 = med1 >= nums1.length ? Integer.MAX_VALUE : nums1[med1];
        int medVal2 = med2 >= nums2.length ? Integer.MAX_VALUE : nums2[med2];
        if(medVal1 <= medVal2) {
            return findKElementRecursive(nums1, start1 + k / 2, nums2, start2, k - k / 2);
        } else {
            return findKElementRecursive(nums1, start1, nums2, start2 + k / 2, k - k / 2);
        }
    }
}
```
